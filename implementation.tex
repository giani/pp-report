In Section~\ref{sec:appr} we discussed our mechanism for implementing watchpoint for memory operations. We also described the details of shadow memory \& meta-information and how it can is used for tracking rcu synchronization primitive. In this section we will describe our implementation detail, the challenges we faced and our solution for them.

One of the important challenge while implementing our system was most of the RCU primitives are defined as macro and inline functions which gets embedded into binary module. Granary being a DBI tool doesnâ€™t know when one of these rcu interface function gets called. To handle this we annotated RCU functions that gives a callbacks to kernel wrapper on the uses of RCU primitives. This was particularly helpful since it provided the infrastructure to track the usage of rcu primitive and update the meta-information. The updated meta-information is then used to check the violation of RCU rules and possible bugs. the section below discusses the different memory access policy rcu protected data should follow and how meta-information is used in enforcing them: 

\begin {itemize} 
	\item \emph{Access of RCU protected inside RCU read critical section :} Our system checks the access of RCU protected We use thread and watchpoint generation number to verify the access of RCU protected data in read critical section. Our system increases thread generation number whenever it encounters \emph{rcu\_read\_lock()}(enters read critical section) and further increases it when comes out of the read critical section(\emph{rcu\_read\_unlock()}), making thread generation number even when it enters the read critical section and odd when it comes out of the read critical section. During access of RCU protected data our callback verifies that the thread generation number is even and the access is happening in read critical section.

	\item \emph{Recursive use of rcu read critical section :} One of the important complexity involved in previous approach is recursive use of read critical section. To handle recursive use of read critical section we increase the thread generation number only when we encounter first \emph{rcu\_read\_lock()} and last \emph{rcu\_read\_unlock()}. We also count the number of read lock and read unlock using thread local slot which ensures that the number of read lock and read unlock always matches.

	\item \emph{ Direct access of RCU protected data in read critical section :} Any direct access of RCU protected data inside read critical section is not allowed. To check the direct access of rcu protected data from direct access we encode the pointer aliasing information in meta-data, which is set inside \emph{rcu\_dereference()}. This allows us to check the direct access of RCU protected data and if the access is happening through one of the alias pointer.

	\item \emph{ Reference of RCU protected data obtained using \emph{rcu\_dereference} must be used within same critical section :} As mentioned above the thread generation number is used to check the access of rcu protected data. To check the access of RCU protected data in the same critical section in which it is dereference by using watchpoint generation number. Our system checks for the thread generation number when it calls \emph{rcu\_dereference} to verify if it is called inside a read critical section and then sets the same thread generation number as watchpoint generation number. Whenever the access of reference pointer happens it checks if the pointer is one of the alias pointer or not and if yes then what is the generation number and if that is same as the thread generation number. 

	\item \emph{ Reference of rcu pointer by its own thread till it gets published using \emph{rcu\_assign\_pointer()}:} To update the rcu protected data structure, a thread needs to make a local copy of the data it needs to modify till the publish has happen and no other thread should have subscription for that pointer. This can be easily handled by using thread local variable by the programmer. Our system also ensures this by maintaining \emph{writer\_thread\_id} with watchpoint meta-information and the data is only allowed to modify and refer by its writer thread id till the publish has not happened(inside \emph{rcu\_assign\_pointer()}).
\end{itemize}


To implement our watchpoint we used non-canonical addresses which gets generated out of actual memory address and the shadow memory index. Our system uses binary instrumentation to find out any such addresses and fixes it to get the correct address before memory operation. We are using Granary, a comprehensive kernel module instrumentation framework, which only rewrites the kernel module code and loses its control when non-module code executes. This makes it possible to leak any of these addresses to leak to the kernel which when accessed causes general protection fault. To handle such cases our system takes control of interrupt handler and gives a callback in case of general protection fault. This callbacks checks for any such watched addresses in registers and the stack and fixes them before doing \emph{iret}. The callback also prevents call to kernel general-protection fault in such cases which prevents any overhead due to kernel general protection fault handler. We tested the changes we did in page-fault handler with different modules but in-case of rcutorture module we have not encountered any such addresses leaking to the kernel.
