Previous section describes about the importance of Read Copy Update (RCU) in parallel programming paradigm and the rules one should follow to correctly use the RCU. It also discusses about the violation of the RCU rules which can act as potential bug in program. we also discussed the challenges involved in identifying such bugs and some of the existing approaches like static analysis, lock-set based approach etc used to identify them. All these solution is limited in their approach in identifying such bugs.

\emph{TODO : discuss some limitations}  

In our mechanism to enforce the RCU rules and identify the violation of these rules, thus potential bugs, involve the use of Dynamic Binary Instrumentation (DBI). Dynamic Binary Instrumentation (DBI) is an execution control and analysis technique that involves injecting binary code into a running program. The injected code is term “Instrumentation”. There are many DBI infrastructure exist like DynamoRIO, DynamoRIO Kernel (DRK),  Pin, JIFL, KernInst etc which provides support for fine-grained monitoring and program execution. However, to develop our system we used Granary, a comprehensive kernel module instrumentation framework. The use of granary impose limitation of analysing only the module code, but it is advantageous as it doesn’t impose any overhead when non-module code is running. Granary allows the interaction between the kernel and module through dynamic module and kernel wrapper having rich information about kernel and its types. The dynamic module and kernel wrapper of Granary provides an infrastructure to efficiently add the watchpoint at any memory location. The details about this is discussed in \emph{TODO provide link to section}.


\subsection{Granary}
Granary is a Dynamic Binary Instrumentation (DBI) framework, which is developed over DynamoRIO Kernel (DRK) and provides support for fine-grained instrumentation of only kernel module. Granary gets loaded as the kernel module and interposes during module loading mechanism to generate dynamic module wrapper. It also use the rich kernel type informations to generate a static kernel wrapper and once the module gets loaded loaded, it runs under the control of Granary and all interactions between the kernel and module happens through one of these wrappers. The presence of these wrappers provides an efficient infrastructure to add watchpoint on the pointers passed from kernel to the module.   


\subsection{Watchpoint}
Program debugging is a tedious but inevitable chore in software development process. An efficient debugger can make programs more productive by allowing them to monitor the execution, inspect the state of the process and monitor memory read and write to inspect the data flow and corruption. This increases the requirement of an efficient debugging tool supporting an useful feature \emph{Watchpoint}. The need of such debugging tool increases as the complexity of the program grows such as parallel system. \emph{Watchpoint} allow a developer to demarcate a memory region and take control whenever that gets accessed. It is similar to the instruction breakpoints which allows the developer to pause execution at specific instructions.

Implementing software watchpoint, without any architectural support, is expensive since it requires to inspect all memory operations and trigger a callback on the watched addresses. Our system leverages the advances in binary instrumentation and code manipulation technique to provide an efficient feature to add watchpoint at memory addresses. We used this feature to check the correct usage of RCU protected data, thus checking the violation of RCU rules and possible bugs in the program.

The naive approach of implementing watchpoint using dynamic binary instrumentation adds new instructions before/ after every memory references to performs the following task: 
\begin{itemize}
	\item Determine the list of addresses which needs to be watched and check if the program is referring to one of the watched addresses.  
	\item Raise a callback when memory operation happens at one of the watched addresses.
	\item Incase the address is not one of the watched addresses then continue the normal execution.
\end{itemize}  
The system also maintains a watchlist lookup table to efficiently look for the addresses before making a callback. One of the drawback of this approach is the runtime overhead of lookup in the watchlist which happens for every memory addresses. This makes the implementation of watchpoint costly. 

Our system refines the cost of adding watchpoint by substantially reducing the cost of lookup and providing options for faster lookup of meta information in shadow memory. The detail about shadow memory and meta information is provided in section \emph{TODO : refer the section}. We took the advantage of 48 bit implementation in 64-bit architecture and used non-canonical addresses to implement the watchpoint mechanism. The use of non-canonical address provides us the following advantages :
\begin{itemize}
	\item It decreases the cost of lookup as the non-canonical addresses can be easily recognised by masking 48 bit.
	\item It also provides one to one mapping between the actual address and watched address thus proving virtually no cost for fixing the address.
	\item It provides 15 bits to encode some information about the watched address.
	\item The address aliasing the watched address also gets watched.
\end{itemize}   





In the previous section we have discussed the several policies/assumptions one should follow to correctly use the RCU synchronization features. The mechanism we used to enforce these policies involves Dynamic Binary Instrumentation(DBT). To develop our system we used a new DBI infrastructure, Granary, which is developed over DynamoRIO kernel (DRK) and only instruments linux kernel modules. 

\subsection{Granary}
Dynamic Binary Instrumentation (DBI) is an execution control and analysis technique that involves injecting binary code into a running program. The injected code is term “Instrumentation”. DBI Infrastructure like DynamoRIO, Pin, JIFL, KernInst provides the infrastructure needed to perform fine-grained monitoring of program execution. However to implement our system we used Granary, a DBI infrastructure for instrumenting linux kernel modules. The advantage of using Granary over other instrumentation framework is it doesn’t cause any overhead for non-module code. Granary gets loaded as a modules and interpose when other kernel modules gets loaded to get control. Granary contains knowledge of all kernel types and provide support for fine-grained instrumentation.

\subsection{Watchpoint}
Program debugging is a tedious but inevitable chore in any software development process. An efficient debugger can make programs more productive by allowing them to monitor the execution, inspect the state of the process and monitor any read and write to memory to inspect the data flow and corruption. The need of an efficient debugging tool supporting watchpoint increases with the complexity of the program. A particular useful feature for debugging that helps in debugging the program execution and data flow is \emph{watchpoint} or \emph{Data breakpoint}. \emph{Watchpoint} allow a developer to demarcate a memory region and take control whenever that gets accessed. It is similar to the instruction breakpoints which allows the developer to pause execution at specific instructions.

Implementing  \emph{Watchpoints} are very expensive without any architectural support since it requires to inspect all memory read and writes and every memory operation needs to trigger some callback which then will inspect the operation.  In this project we leverage the advances in binary instrumentation and code manipulation to provide an efficient feature to add watchpoint at all memory accesses. We use Granary, a comprehensive kernel module instrumentation framework, to develop the \emph{Watchpoint} mechanism.

A basic approach of monitoring every memory read and write using dynamic binary instrumentation adds new instructions before every memory references to perform the following task: (1) Determine the list of addresses which needs to be watched, (2) check if the program is referring the watched address, (3) raise a callback when memory operation happens at that address. A naive implementation of this approach is to maintain a watchlist lookup table and instrument all memory read and write to see if program is trying to access any of these memory. \emph{discuss other methods of adding watchpoint}. One of the demerits of these approaches is the cost of looking up for the watched address in the lookup table will be costly and will decrease the performance.

We refined the approach of adding watchpoint in the two ways which will substantially reduce the cost of lookup.  First we used the non-canonical address to add the watchpoint in the addresses. The use of  non-canonical address as the watchpoint provides to various advantages. (1) decrease the cost of lookup for the watched address, (2) provides several bits of to store index of meta-informations.

\subsection {Binary Instrumentation and Optimizations}

This section describes the instrumentation scheme we used to implement watchpoint and few optimizations we used for lookup and handling local variables. The instrumentation schemes inserts instructions to check the watch address before every memory reference. The instrumentation performs the following operation before/after memory reference :

\begin{itemize}
\item Save and restore the registers that are used or side-effected during watchpoint( stack is used to spill these registers ).
\item Calculate the reference address and check if this is one of the non-canonical addresses.
\item Calculate the actual address if this is one of the non-canonical one and make a call to policy verifier function with actual address and the shadow memory index. 
\item Emulate the actual instruction with corrected address and continue the execution after restoring registers.
\end{itemize}

Figure shows the example of memory operation and how it looks after instrumentation.The naive instrumentation which is described in the figure can cause significant runtime overhead. In-order to improve the runtime performance we implemented some optimizations : register liveness analysis and local variable check elimination. 

\begin{itemize}
\item \emph{Register Liveness Analysis}
\item \emph{Local variable Check Elimination}
\end{itemize} 

There are other optimization which can further reduce the monitoring overhead but due to the time constraint we choose not to implement that for this couse due to time constraints.


\subsection{Shadow memory and meta information}
This section describes about the shadow memory and meta-information we used for implementing rcu policies. Shadow memory provides an efficient infrastructure for implementing watchpoint mechanism. Different binary rewriter framework provides support for shadow memory differently and Granary, build over Dynamorio Kernel, also provides support for shadow memory framework, Umbra. However in our approach we split and reserve a part of address space as shadow memory. Our approach of shadow memory is better than Umbra as it simplifies the shadow address calculation and there is no overhead of address lookup. The shadow memory is used to store the meta-information necessary for implementing RCU policies. The figure shows the structure used for storing the meta-information. 

\begin{figure}[h]
\centering
\begin{lstlisting}
/// Thread-specific watchpoint meta information.
struct alias_meta_thread {

    // spin lock and free list for allocating RCU thread meta info.
    static volatile mem_t LOCK;
    static alias_meta_thread *FREE_LIST;

    // for linking in the free list.
    alias_meta_thread *next;

    // writer thread_id + 1 iff this RCU-protected structure is being
    // written to; otherwise 0. An RCU-protected structure is writable from
    // the time of allocation up until it is published using rcu_assign_pointer.
    uint64_t writer_thread_id;

    // The "generation" number of the thread
    uint64_t gen_nums[NUM_THREADS];
    ...
};

struct alias_meta {

    union {

        // if this watchpoint aliases another watchpoint
        alias_meta *source;
        // thread info about a source watchpoint
        alias_meta_thread *thread_info;
        uint64_t address;
    } u;
    ...
}; 
\end{lstlisting}
\caption{Meta-Information: data structure used for meta-info}\label{fig:metainfo}
\end{figure}

The shadow memory stores a large array of meta information which can be accessed by the index stored with the watchpoint. The meta-information gets generated and stored during the rcu data allocation and its index is used to generate watched address. Our meta-information also keeps track of pointer aliasing. The two elements \emph{source} and \emph{thread\_info} helps in tracking the pointer aliasing which is particularly useful in tracking rcu bugs violating rule 1.

The meta-information contains the thread specific generation number and writer \emph{thread\_id} which is allowed to modify it before publish. These thread specific meta-information gets generated at runtime while adding watchpoint. The figure below shows the structure of per-pointer meta-information.

Apart from the per-pointer meta-information we also store the per-thread meta information. These per-thread information gets stored at the thread local slots created at the bottom of the stack. These thread-local-storage (TLS) is also used to store the generation number which is then used to check the correct usage of RCU.

\subsection{Page fault handler}
To implement our watchpoint we used non-canonical addresses which gets generated out of actual memory address and the shadow memory index. Our system uses binary instrumentation to find out any such addresses and fixes it to get the correct address before memory operation. We are using Granary, a comprehensive kernel module instrumentation framework, which only rewrites the kernel module code and loses its control when non-module code executes. This makes it possible to leak any of these addresses to leak to the kernel which when accessed causes general protection fault. To handle such cases our system takes control of interrupt handler and gives a callback in case of general protection fault. This callbacks checks for any such watched addresses in registers and the stack and fixes them before doing \emph{iret}. The callback also prevents call to kernel general-protection fault in such cases which prevents any overhead due to kernel general protection fault handler. We tested the changes we did in page-fault handler with different modules but in-case of rcutorture module we have not encountered any such addresses leaking to the kernel.

