Previous section describes about the importance of Read Copy Update (RCU) in parallel programming paradigm and the rules one should follow to correctly use the RCU. It also discusses about the violation of the RCU rules which can act as potential bug in program. we also discussed the challenges involved in identifying such bugs and some of the existing approaches like static analysis, lock-set based approach etc used to identify them. All these solution is limited in their approach in identifying such bugs.

\emph{TODO : discuss some limitations}  

In our mechanism to enforce the RCU rules and identify the violation of these rules, thus potential bugs, involve the use of Dynamic Binary Instrumentation (DBI). Dynamic Binary Instrumentation (DBI) is an execution control and analysis technique that involves injecting binary code into a running program. The injected code is term “Instrumentation”. There are many DBI infrastructure exist like DynamoRIO, DynamoRIO Kernel (DRK),  Pin, JIFL, KernInst etc which provides support for fine-grained monitoring and program execution. However, to develop our system we used Granary, a comprehensive kernel module instrumentation framework. The use of granary impose limitation of analysing only the module code, but it is advantageous as it doesn’t impose any overhead when non-module code is running. Granary allows the interaction between the kernel and module through dynamic module and kernel wrapper having rich information about kernel and its types. The dynamic module and kernel wrapper of Granary provides an infrastructure to efficiently add the watchpoint at any memory location. The details about this is discussed in \emph{TODO provide link to section}.


\subsection{Granary}
Granary is a Dynamic Binary Instrumentation (DBI) framework, which is developed over DynamoRIO Kernel (DRK) and provides support for fine-grained instrumentation of only kernel module. Granary gets loaded as the kernel module and interposes during module loading mechanism to generate dynamic module wrapper. It also use the rich kernel type informations to generate a static kernel wrapper and once the module gets loaded loaded, it runs under the control of Granary and all interactions between the kernel and module happens through one of these wrappers. The presence of these wrappers provides an efficient infrastructure to add watchpoint on the pointers passed from kernel to the module.   


\subsection{Watchpoint}
Program debugging is a tedious but inevitable chore in software development process. An efficient debugger can make programs more productive by allowing them to monitor the execution, inspect the state of the process and monitor memory read and write to inspect the data flow and corruption. This increases the requirement of an efficient debugging tool supporting an useful feature \emph{Watchpoint}. The need of such debugging tool increases as the complexity of the program grows such as parallel system. \emph{Watchpoint} allow a developer to demarcate a memory region and take control whenever that gets accessed. It is similar to the instruction breakpoints which allows the developer to pause execution at specific instructions.

Implementing software watchpoint, without any architectural support, is expensive since it requires to inspect all memory operations and trigger a callback on the watched addresses. Our system leverages the advances in binary instrumentation and code manipulation technique to provide an efficient feature to add watchpoint at memory addresses. We used this feature to check the correct usage of RCU protected data, thus checking the violation of RCU rules and possible bugs in the program.

The naive approach of implementing watchpoint using dynamic binary instrumentation adds new instructions before/ after every memory references to performs the following task: 
\begin{itemize}
	\item Determine the list of addresses which needs to be watched and check if the program is referring to one of the watched addresses.  
	\item Raise a callback when memory operation happens at one of the watched addresses.
	\item Incase the address is not one of the watched addresses then continue the normal execution.
\end{itemize}  
The system also maintains a watchlist lookup table to efficiently look for the addresses before making a callback. One of the drawback of this approach is the runtime overhead of lookup in the watchlist which happens for every memory addresses. This makes the implementation of watchpoint costly. 

Our system refines the cost of adding watchpoint by substantially reducing the cost of lookup and providing options for faster lookup of meta information in shadow memory. The detail about shadow memory and meta information is provided in section \emph{TODO : refer the section}. We took the advantage of 48 bit implementation in 64-bit architecture and used non-canonical addresses to implement the watchpoint mechanism. The use of non-canonical address provides us the following advantages :
\begin{itemize}
	\item It decreases the cost of lookup as the non-canonical addresses can be easily recognised by masking 48 bit.
	\item It also provides one to one mapping between the actual address and watched address thus proving virtually no cost for fixing the address.
	\item It provides 15 bits to encode some information about the watched address.
	\item The address aliasing the watched address also gets watched.
\end{itemize}   

Figure shows the address-space layout in 64 bit architecture with 48 bit implementations. It also shows the mechanism we used to get the watched address by masking 16 bit and vice-versa.

\emph{TODO : Add figures for non-cannonical addresses}


\subsection {Instrumentation and Optimizations}
Implementing watchpoint requires monitoring of every memory operation. A naive approach of tracking every memory read and write operation requires adding new instructions before every memory references. The use of naive instrumentation scheme poses significant overhead as it adds bunch of instrumentation across instructions. we refined our approach of adding watchpoint by using non-canonical address which makes the lookup faster. The detail of which is provided in previous section. The instrumentation performs following operation to every memory reference :

\begin{itemize}
	\item Save and restore the registers that are used or side-effected during watchpoint( stack is used to spill these registers ).
	\item Calculate the reference address and check if this is one of the non-canonical addresses.
	\item Calculate the actual address if this is one of the non-canonical one and make a call to policy verifier function with actual address and the shadow memory index. 
	\item Emulate the actual instruction with corrected address and continue the execution after restoring registers.
\end{itemize}

Figure shows example of memory operation and how it looks after instrumentation. Our instrumentation also uses some optimization to improve the runtime performance. We used the following optimizations :  

\begin{itemize}
	\item \emph{Register Liveness Analysis}
	\item \emph{Local variable Check Elimination} :  It identify the local variable references via the stack pointer reference.
\end{itemize} 

There are other optimization like Group checks and the policy based instrumentation which can further reduce the overhead but due to the time constraint we choose not to implement them for this course.


\subsection{Shadow memory and meta information}
This section describes about the meta-information we use to verifying rcu policies. Our system tracks two types of meta-information :
\begin{itemize}
	\item Per thread meta-information
	\item Per pointer meta-information
\end{itemize} 

The per thread meta-information includes the generation number which gets stored at the thread local slot created at the bottom of the stack. The thread local generation number keeps track of the rcu read critical section and used to validate the correct usage of RCU protected pointer. 



The per pointer meta information gets stored in the shadow memory and includes the writer thread id, and per thread generation number. The structure of the per pointer meta-information is shown in the figure. The shadow memory stores a large array of \emph{union alias\_meta} which includes \emph{ alias\_meta\_thread *thread\_info} as the element. The \emph{thread\_info} stores the id of thread who allocates the memory. It also contains an array which stores the \emph{Generation number} for each thread. 

We also used an efficient approach to implement shadow memory. Shadow memory provides an efficient infrastructure for implementing watchpoint mechanism. There are many binary instrumentation framework which provides support for shadow memory framework. DynamoRIO kernel also provides the support for Umbra, a shadow memory framework. However, in our approach we split and reserve a part of address space as shadow memory. Our approach of shadow memory is better than Umbra as it simplifies the shadow address calculation and there is no overhead of address lookup. The shadow memory includes a large array of 

\begin{figure}[h]
\centering
\begin{lstlisting}
/// Thread-specific watchpoint meta information.
struct alias_meta_thread {
    // for linking in the free list.
    alias_meta_thread *next;

    // writer thread_id + 1 iff this RCU-protected structure is being
    // written to; otherwise 0. An RCU-protected structure is writable from
    // the time of allocation up until it is published using rcu_assign_pointer.
    uint64_t writer_thread_id;

    // The "generation" number of the thread
    uint64_t gen_nums[NUM_THREADS];
};

union alias_meta {
        // if this watchpoint aliases another watchpoint
        alias_meta *source;
        // thread info about a source watchpoint
        alias_meta_thread *thread_info;
}; 
\end{lstlisting}
\caption{Meta-Information: data structure used for meta-info}\label{fig:metainfo}
\end{figure}



The shadow memory stores a large array of meta information which can be accessed by the index stored with the watchpoint. The meta-information gets generated and stored during the rcu data allocation and its index is used to generate watched address. Our meta-information also keeps track of pointer aliasing. The two elements \emph{source} and \emph{thread\_info} helps in tracking the pointer aliasing which is particularly useful in tracking rcu bugs violating rule 1.

The meta-information contains the thread specific generation number and writer \emph{thread\_id} which is allowed to modify it before publish. These thread specific meta-information gets generated at runtime while adding watchpoint. The figure below shows the structure of per-pointer meta-information.

Apart from the per-pointer meta-information we also store the per-thread meta information. These per-thread information gets stored at the thread local slots created at the bottom of the stack. These thread-local-storage (TLS) is also used to store the generation number which is then used to check the correct usage of RCU.

\subsection{Page fault handler}
To implement our watchpoint we used non-canonical addresses which gets generated out of actual memory address and the shadow memory index. Our system uses binary instrumentation to find out any such addresses and fixes it to get the correct address before memory operation. We are using Granary, a comprehensive kernel module instrumentation framework, which only rewrites the kernel module code and loses its control when non-module code executes. This makes it possible to leak any of these addresses to leak to the kernel which when accessed causes general protection fault. To handle such cases our system takes control of interrupt handler and gives a callback in case of general protection fault. This callbacks checks for any such watched addresses in registers and the stack and fixes them before doing \emph{iret}. The callback also prevents call to kernel general-protection fault in such cases which prevents any overhead due to kernel general protection fault handler. We tested the changes we did in page-fault handler with different modules but in-case of rcutorture module we have not encountered any such addresses leaking to the kernel.

