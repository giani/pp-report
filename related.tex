Application debugging is a necessary part of software development cycle. There are many software, hardware and hybrid technique exists for debugging. The importance of such debugging technique increases as the complexity of software increases. Read Copy Update (RCU) is one of the synchronization technique which is heavily used in the linux kernel because of its lightweight read-side overhead. Programming of software system using RCU is complex and often lead to bugs due to its incorrect usage. Debugging such incorrect usage of rcu primitive is challenging as one needs to follow many rules \& assumptions to verify its correct usage. 

\subsection{RCU debugging}
There are many existing solution which is used for analysing the incorrect usage of RCU synchronization primitive. Sparse~\cite{sparse} is one of the existing tool which uses static analysis method to verify the correct usage of RCU. It uses \emph{\_\_rcu} tag to annotate the RCU protected pointers and flags traversals of RCU-protected pointers that are not properly protected either by an RCU read-side critical section or an update-side lock. One of the demerits of using sparse is its output gets heavily ridden with false positives, requiring more time and effort to interpret. Lockdep-RCU is another method which is used for analysing the incorrect usage of \emph{rcu\_derefence()}. It emits a runtime error if they gets executed outside of an RCU read-side critical section. One of the important limitation with Lockdep-RCU~\cite{PaulEMcKenney2010LockdepRCU} solution is it catches only the incorrect usage of \emph{rcu\_derefence()} and \emph{rcu\_assign\_pointer()}. 

\subsection{Watchpoint}
Watchpoint is an important debugging facility that helps developers track the memory references. Almost all the hardware state-of-the-art processor provides support for limited hardware watchpoints. There has been several proposal in the past on implementing software watchpoint and some of them using methods of Dynamic Binary Instrumentation(DBI).
%makes the case for supporting an unlimited number of watchpoints. A hardware solution is proposed and multiple applications are described. Unlike our approach, the cited approach depends on specialised hardware and requires that applications using these watchpoints maintain their own context-specific information.
%In , 
\paragraph{Software-based}
Zhao \emph{et al.}~\cite{Zhao:2008} describe a method of implementing an efficient and scalable DBT-based watchpoint system. His method uses page protection and indirection through a hash table to track watched memory. This approach does not support watching ranges of memory, nor does it support context-specific information. Lueck \emph{et al.} \cite{PinADX} introduce semantic watchpoints as part of the PinADX system, an extension of the PIN DBT framework. PinADX enables interactive debugging by triggering debugger breakpoints when semantic conditions are met. While similar in spirit to behavioural watchpoints, semantic watchpoints do not maintain context-specific, per-watchpoint state. Wahbe \emph{et al.}~\cite{Wahbe:1992} also proposes the implementation of software watchpoint using code patching and static analysis.  Another interesting approach proposed by keppel \emph{et al.}~\cite{Keppel:93a} to use checkpoint for memory updates. But one of the important thing about all of these works is they are only valid for userspace. The latest patches of MemCheck in Valgrind~\cite{Seward:2005} also provides the support of adding watchpoint. They uses link-list to maintain the watchlist. This puts a sevear restriction on their performance.   

\paragraph{Hardware-based}
Greathouse \emph{et al.}~\cite{UnlimitedWatchpoints} propose a hardware solution that efficiently supports an unlimited number of watchpoints. Witchel and Asanovic \cite{Mondrix} describes the implementation of memory protection domains for the Linux kernel. Protection domains are implemented using specialised hardware and enable fine- and coarse-grained memory protection using a mechanism similar to hardware watchpoints. Unlike our approach, both \cite{Mondrix} and \cite{UnlimitedWatchpoints} depend on specialised hardware and require that applications using this hardware  separately maintain context-specific information. Suh \emph{et al.} \cite{SecureProgramExecFlowTracking} proposes a method of secure program execution by tracking dynamic information flow. Memory tagging at the hardware level allows their system to track tainted data as it propagates through a running program. Behavioural watchpoints are similar insofar as a watched address is tagged, and this tag propagates through a program.
