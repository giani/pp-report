Programming with RCU is a completely different paradigm as compared to traditional
synchronization techniques. Due to its design, care must be taken in dereferencing
shared data. Critical sections must also be clearly defined.


\begin{figure}[h]
\centering
\begin{lstlisting}
rwlock_t q_lock;
global datatype *q;

f() {
	...
	rwlock_read_lock(&q_lock);
	do_something(q);
	rwlock_read_unlock(&q_lock);
	...
}
\end{lstlisting}
\caption{Using Spinlocks}\label{fig:rwuse}
\end{figure}

\begin{figure}[h]
\centering
\begin{lstlisting}
global datatype *q;

f() {
	dataype *p;
	...
	rcu_read_lock();
	p = rcu_dereference(q);
	do_something(p);
	rcu_read_unlock();
	...
}
\end{lstlisting}
\caption{Using RCU}\label{fig:RCUuse}
\end{figure}

Figure~\ref{fig:rwuse} shows how a
typical Reader Writer lock works. q is the shared data which various readers
and writers wish to access. q\_lock is used to synchronize access to q.
First the reader locks the rwlock, q\_lock,
in the read mode. It then goes ahead an reads the data in q. Finally once it is
done, it unlocks the rwlock.

In contrast Figure~\ref{fig:RCUuse} gives an example of how RCU is used. q is a global pointer
which points to some data which is protected with the use of RCU. When a reader
wishes to dereference that data, it first announces the beginning of an RCU critical
section. Then in order to derefence that data, it uses rcu\_dereference. At this
point it holds a legal reference and RCU guarantees that structure will not be
reclaimed at least until this reader announces the end of the critical section.
The reader now proceeds to go ahead and use the reference it has. Finally once it
is done, it announces the end of a critical section.

As can be seen, as opposed to locking on a rwlock, RCU readers just announce they
have entered a critical section. Then in order to ensure that access is not
interrupted, they use rcu\_dereference to get a reference. Finally all accesses
to the shared data is through the use of p. RCU guarantees that the data structure
will not be reclaimed till the reader announces the end of its critical section.

There are two terms that need to be defined in the context of RCU in order to aid
any discussion.
\begin{itemize}
\item{Quiescent State}: This is the state when a reader is not in an RCU critical state
\item{Grace Period}: Any time period during which each thread has been observed in at least one quiescent state.
\end{itemize}

RCU has a list of well defined API. The most commonly used are
\begin{itemize}
\item{rcu\_read\_lock}: Used to announce the beginning of a critical section.
\item{rcu\_read\_unlock}: Used to announce the end of a critical section.
\item{rcu\_dereference}: Used to obtain a reference to shared data
\item{rcu\_assign\_pointer}: Used to announce an update.
\item{synchronize\_rcu}: Used to wait till a grace period has passed.
\item{call\_rcu}: Used to queue up a callback that takes place at some future time.
\end{itemize}


Using RCU requires careful attention from the programmer. There are some rules
and inherent assumptions while using RCU. For example, access to shared data
should only happen with a reference which has been obtained with the use of
rcu\_dereference. This call should also happen only after an RCU read critical
section has announced. Any use of this reference obtained must be made before
this critical section ends. If a new critical section has been announced a
fresh reference must be obtained with the use of rcu\_dereference. A quiescent
state (in some flavours of RCU) must only be announced once it has actually
taken place. On the update side, an update should only take place with use
of rcu\_assign\_pointer. There are many other similar rules that must be
followed.
